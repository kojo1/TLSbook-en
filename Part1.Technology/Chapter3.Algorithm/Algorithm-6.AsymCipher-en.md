### 3.6.5 Digital signature

Digital signature (public key signature) verifies the authenticity of a message. Since a digital signature can only be generated by a legitimate signer, it can confirms the signer and, conversely, to prevent denial that the signature was generated.

If you only want to verify the correspondence between the message and the signature, you can use the message authentication code (MAC) with a common key. However, MAC allows a signature verifier who knows the key to generate a legitimate signature, so it cannot be used to confirm the legitimate signer or prevent signature denial.

When signing with a public key, the signature generation key and the verification key are different, so only those with a private key can sign. Therefore, by checking the validity of the signature, it is possible to confirm that the signature is from a legitimate signer. It can also prevent denial of signing.

Figure 3-6-3 shows the structure of a digital signature. Digital signatures first generate a fixed-length hash value for the target message so that you can sign a message of arbitrary length. Signature generation uses this hash value and some secret value (signature key) known only to the signer to generate the signature. Signature verification, on the other hand, verifies the validity of the signature based on the hash value, the signature and the key for signature verification.

<br>

![3-6-3](./fig3-6-3.jpg)

<br>

#### 1) RSA signature

In RSA signature, signature generation and verification are realized by cyclic group which is encrypted by RSA operation returns to the original by decryption. The signature is generated from the hash value of the message using the key equivalent to the public key in the RSA encryption algorithm and the algorithm equivalent to encryption.

On the signature verification side, it uses the hash value of the message, the signature, and the key for signature verification. The verification key corresponds to the private key for decryption during encryption. If the signature verification key yields the original hash value, then the message and signature have been validated.


![3-6-4](./fig3-6-4.jpg)

<br>

With RSA signing, the signing key is kept secret only by the signer, and the verification key is made public for verification. In principle, it can be realized by using the same algorithm as RSA encryption and decryption by using it in the opposite way to public and private for encryption and decryption. However, in the signature schemes standardized as today's practical RSA signatures, the padding schemes are different from those for encryption scheme and cannot be diverted to each other.


### 2) DSA signature

DSA (Digital Signature Algorithm) signature uses the fact that the same value can be obtained between two different combinations of one-way operations, instead of using a cyclic group like RSA signature. One of the features is that it does not require tampering prevention using padding because it does not use a cyclic group.

On the other hand, DSA is difficult to generate an appropriate key and requires careful attention. In addition, it is necessary to generate a new key for each signature so that the key cannot be decrypted. For this reason, RSA signatures are more widely used in the world of integer arithmetic. However, since no cyclic group has been found in elliptic curve cryptography, ECDSA and EdDSA (explained in the ECC chapter), which have realized an algorithm equivalent to DSA in the world of integer arithmetic in the world of elliptic curve cryptography, are widely used.

Figure 3-6-5 shows the flow of DSA signature and verification. Here, we will only explain the flow of signing and verification using the generated key to understand the principle of DSA.

Let's look at the flow of the signature generation and verification boxes. The two boxes on the right side of the figure are the signature generation, and the left side is the verification part. The message shall have a fixed length value with the appropriate hash function H (m).

In the signature generation, it can be seen that the signature values ​​r and s are obtained by inputting the hash value H (m) and the random number value k generated as the signature key. Of these, the value r is the remainder of the power to be obtained from the signature key k and the common parameters, and is similar to the one-way operation used in RSA or DH. Since it is a one-way operation, the confidentiality of the key k can be maintained even if this value is disclosed as the signature value.

The other value s is obtained from the key k and the hash value H (m), but it is taken over by the signature verification flow and is part of the other one-way operation flow.

In the verification, the value v for verification is obtained by inputting this value s and the hash value. The operation of the value v is such that the value of H (m) is erased during the calculation, and if the signature is correct regardless of H (m), the resulting value can be obtained on the signature generation side. It will be the same value as the existing value r.

However, as you can see in the figure, H (m) is used in both the signature generation side and the verification side operations. Therefore, the value s, which is the result of the operation, and the process of calculating the value v based on the value of s also depend on H (m), and H (m) is integrated in both signature generation and verification. If is not given, the correct value v cannot be obtained. In other words, if H (m) is different between the two, the verification will fail.


<br>

![3-6-5](./fig3-6-5.jpg)
<br>
